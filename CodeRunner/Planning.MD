Game Title: CodeRunner-Quest
Theme/Focus:
You‚Äôre a digital explorer inside a glitched computer world. The game is a 2D infinite ‚Äúcode stream‚Äù platformer, where you run through never-ending streams of data made of code fragments, memory blocks, and digital traps. Instead of hand-made maps, everything is procedurally generated‚Äîso it‚Äôs always fresh, never repetitive.

You must dodge bugs, collect data packets, solve short logic puzzles while running, and shift between "Debug Mode" and "Live Mode" to interact with different types of obstacles. It‚Äôs fast, satisfying, and full of cool mini-challenges and upgrades as you progress.

Phase 1: Core Systems + Infinite Stream Demo ‚úÖ COMPLETED
Goal: Build a playable demo where:

‚úÖ The player moves and jumps

‚úÖ The world scrolls infinitely

‚úÖ Tiles and obstacles generate automatically

‚úÖ You can switch modes (Debug/Live) to avoid different traps

SECTION 1: Project Setup ‚úÖ COMPLETED
‚úÖ Create folders:

src/ ‚Äì all game code

assets/ ‚Äì placeholder sprites (boxes, icons)

data/ ‚Äì if needed for configs

‚úÖ Make index.html with <canvas>

‚úÖ Make game.js with a working game loop:

update() for logic

draw() for rendering

requestAnimationFrame() for timing

SECTION 2: Player System ‚úÖ COMPLETED
‚úÖ Create a player object with:

x, y position

vx, vy velocity

width, height

mode = "live" or "debug"

‚úÖ Handle keyboard input:

Left/right to move

Space to jump

Tab (or Shift) to swap modes

‚úÖ Add gravity and floor collision

SECTION 3: World Generator ‚úÖ COMPLETED
‚úÖ Create a 2D array buffer that stores generated tiles

‚úÖ Each new row randomly spawns:

Safe floor tiles

Gaps (fall traps)

Spikes (only visible in Live mode)

Glitches (only passable in Debug mode)

‚úÖ Continuously shift the world leftward as the player "runs"

‚úÖ Generate new chunks as the old ones go off screen

SECTION 4: Mode-Swap System ‚úÖ COMPLETED‚úÖ Add a simple toggle between Live and Debug

‚úÖ In Live mode:

Spikes are visible and dangerous

Glitch blocks don‚Äôt appear

‚úÖ In Debug mode:

Spikes disappear

Glitch blocks appear and are solid

‚úÖ Add a short cooldown to prevent spamming mode switch

SECTION 5: Basic Collision + Game Over ‚úÖ COMPLETED
‚úÖ Detect when the player touches:

Spikes (in Live mode) ‚Üí lose

Falls into gap ‚Üí lose

‚úÖ Simple game over screen and restart key

================================================================================
üöÄ STARTING PHASE 2: Gameplay Depth + Progression Systems
================================================================================
Date Started: May 30, 2025

Phase 2: Gameplay Depth + Progression Systems üéØ IN PROGRESS
Goal: Make the game feel deeper and more rewarding. Add things to keep the player coming back: scoring, upgrades, mini-challenges, and more dynamic obstacles.

SECTION 6: Scoring & Combo System ‚úÖ COMPLETED
‚úÖ Add a score variable that increases over time and with item pickups

‚úÖ Show score in a corner (HUD)

‚úÖ Add a combo system:

‚úÖ Staying in Live Mode longer without dying increases combo multiplier

‚úÖ Breaking the streak resets combo

‚úÖ Display multiplier on screen

SECTION 7: Data Packets & Pickups ‚úÖ COMPLETED
‚úÖ Generate collectible "data packets" that appear in the stream

‚úÖ In Debug Mode, show corrupted ones that give bonus points

‚úÖ Add a simple animation when collected

‚úÖ Store total pickups for future upgrades

‚úÖ Implemented floating point animations for collected packets

‚úÖ Added visual rendering with green (normal) and purple (corrupted) effects

‚úÖ Connected to scoring system with combo multipliers

SECTION 8: Temporary Power-Ups ‚úÖ COMPLETED
‚úÖ Create power-ups like:

‚úÖ Slow-Mo Chip: slows scrolling for 5 seconds

‚úÖ Invis-Wipe: makes spikes harmless for a few seconds

‚úÖ Auto-Debug: auto-switches to the correct mode before a trap

‚úÖ Show power-up timer on HUD

‚úÖ Implemented visual power-up spawning in world chunks

‚úÖ Added animated power-up collection and effects

‚úÖ Enhanced player visual feedback when power-ups are active

SECTION 9: Enemy Types (No AI yet) ‚úÖ COMPLETED
üìã Add simple "bug" enemies that move side to side

Only visible in one mode

Touching them causes damage or instant death

 Create hitboxes and basic collisions

 Leave room for ‚Äúpurging‚Äù them later

SECTION 10: Mini-Challenges in Stream ‚úÖ COMPLETED
‚úÖ Randomly generate mini logic puzzles that pause the runner flow:

‚úÖ "Fix the broken loop" ‚Äì re-order lines of fake code

‚úÖ "Binary gate lock" ‚Äì select correct path based on code shown

‚úÖ Optional: reward score bonus or power-up when solved

‚úÖ Skip button available, but costs points

‚úÖ Implemented comprehensive challenge system with two challenge types
‚úÖ Added time limits and visual feedback for challenges
‚úÖ Integrated challenge system with main game loop and pause mechanics
‚úÖ Added debug triggers for testing (C for random, 1 for code loop, 2 for binary gate)

SECTION 11: Basic Upgrade Menu (not permanent yet) ‚úÖ COMPLETED
‚úÖ At game start or game over, show a basic menu:

‚úÖ Upgrade jump height

‚úÖ Increase score multiplier

‚úÖ Extend power-up time

‚úÖ Use data packets (collected in-game) as currency

‚úÖ Upgrades reset when restarting game (save later in Phase 3)

‚úÖ Enhanced animated upgrade menu with visual effects
‚úÖ Menu navigation with arrow keys (‚Üë/‚Üì), Enter/Space to purchase
‚úÖ Real-time cost calculation with scaling prices
‚úÖ Visual feedback for purchases and insufficient funds
‚úÖ Accessible via 'U' key during gameplay

================================================================================
üéØ DIFFICULTY SELECTION SYSTEM COMPLETED - June 2, 2025
================================================================================

SECTION 12: Difficulty Selection & Health Regeneration ‚úÖ COMPLETED
‚úÖ Implemented difficulty selection screen at game start:

üîπ Easy: Fast regeneration - Player health recovers every 1 minute
   Perfect for casual players or those new to the game

üî∏ Medium: Moderate regeneration - Health recovers every 3 minutes  
   Balanced rate designed for players with some experience

üî¥ Hard: Slow regeneration - Health regenerates every 7 minutes
   For experienced players who want a challenge

‚ùå Extreme: No regeneration - Health does not regenerate at all
   Ultimate survival challenge for hardcore players

‚úÖ Enhanced UI features:
   - Beautiful difficulty selection screen with animated particles
   - Color-coded difficulty indicators with emojis
   - Real-time regeneration timer display during gameplay
   - Difficulty indicator shown in top-left corner during play
   - Updated health regeneration system based on selected difficulty

‚úÖ Technical Implementation:
   - Added DIFFICULTY_LEVELS constants with regeneration intervals
   - Created navigateDifficultyUp/Down methods for menu navigation
   - Updated health regeneration system to use difficulty-based timing
   - Enhanced UI to display appropriate regeneration information
   - Integrated difficulty selection into game state management

================================================================================
üîß MAJOR CODE REFACTORING COMPLETED - May 30, 2025
================================================================================

‚úÖ SYNTAX ERRORS FIXED: Resolved all JavaScript syntax errors in game.js (missing braces, method declarations)

‚úÖ MODULAR ARCHITECTURE: Refactored monolithic game.js (1210 lines) into organized modules:
   - camera.js: Camera system for smooth player following
   - scoringSystem.js: Scoring, combos, and data packet collection
   - inputHandler.js: Keyboard input management  
   - renderer.js: All drawing and UI rendering functions
   - game.js: Clean main game engine (reduced to ~280 lines)

‚úÖ IMPROVED CODE ORGANIZATION:
   - Separated concerns into logical modules
   - Eliminated code duplication
   - Enhanced maintainability and readability
   - Added proper error handling

‚úÖ ENHANCED PERFORMANCE:
   - Optimized rendering pipeline
   - Improved camera smoothing algorithms
   - Better memory management for animations

‚úÖ GAMEPLAY IMPROVEMENTS:
   - Smooth and responsive controls
   - Enhanced visual feedback for data packet collection
   - Improved health regeneration system (30-second intervals)
   - Better game over screen with fade effects



   Phase: Debug Mode
üéØ Goal:
Create a dedicated debug mode that helps you:

Track bugs while playing

Toggle important info on screen

Log useful output to the console

Easily activate/deactivate debug mode

üß± Core Structure (Enable/Disable)
 1. Add a Global Debug Toggle
 In main.js or config.js, add a variable:

js
Copy
Edit
let debugMode = true; // Set to false when publishing
 Add a keyboard shortcut to toggle it:

js
Copy
Edit
window.addEventListener("keydown", (e) => {
  if (e.key === "F1") {
    debugMode = !debugMode;
    console.log("Debug mode:", debugMode);
  }
});
üìä On-Screen Debug Info
 2. Draw Player Stats on Screen
 In your render loop (or draw() function), add this inside:

js
Copy
Edit
if (debugMode) {
  ctx.fillStyle = "white";
  ctx.font = "12px monospace";
  ctx.fillText(`x: ${player.x.toFixed(2)}`, 10, 20);
  ctx.fillText(`y: ${player.y.toFixed(2)}`, 10, 35);
  ctx.fillText(`speed: ${player.speed.toFixed(2)}`, 10, 50);
  ctx.fillText(`distance: ${player.distance.toFixed(0)}`, 10, 65);
}
 Add more debug data as needed (tile positions, background offset, etc.)

üß™ Debug Tools for Bugs
 3. Console Log Key Events
 Log when certain things happen:

js
Copy
Edit
if (debugMode) console.log("Tiles spawned:", tiles.length);
if (debugMode) console.log("Player died at distance:", player.distance);
 Log input states (left/right/jump/etc.) to detect lag or missing input:

js
Copy
Edit
if (debugMode) console.log("Input:", input);
üö¶ Visual Debug Indicators
 4. Show Collision Boxes
 In your render() or draw() function:

js
Copy
Edit
if (debugMode) {
  ctx.strokeStyle = "red";
  ctx.strokeRect(player.x, player.y, player.width, player.height);
  
  tiles.forEach(tile => {
    ctx.strokeStyle = "yellow";
    ctx.strokeRect(tile.x, tile.y, tile.width, tile.height);
  });
}
üêõ Optional Debug Features
 5. Add Slow-Motion Debug Mode
 Inside your update() loop:

js
Copy
Edit
if (debugMode && slowMotionEnabled) {
  deltaTime *= 0.25; // Slow everything down
}
 Press F2 to toggle slow motion:

js
Copy
Edit
let slowMotionEnabled = false;
window.addEventListener("keydown", (e) => {
  if (e.key === "F2") {
    slowMotionEnabled = !slowMotionEnabled;
    console.log("Slow motion:", slowMotionEnabled);
  }
});
 6. Add ‚ÄúForce Die‚Äù Shortcut
 Use F3 to simulate game over:

js
Copy
Edit
window.addEventListener("keydown", (e) => {
  if (e.key === "F3") {
    if (debugMode) {
      player.health = 0;
      console.log("Forced death triggered (F3)");
    }
  }
});
7. Add FPS Counter
 Track and draw FPS:

js
Copy
Edit
let lastTime = performance.now();
let fps = 0;

function updateFPS() {
  const now = performance.now();
  const delta = now - lastTime;
  fps = 1000 / delta;
  lastTime = now;
}

function drawFPS(ctx) {
  if (debugMode) {
    ctx.fillStyle = "lime";
    ctx.font = "12px monospace";
    ctx.fillText(`FPS: ${fps.toFixed(0)}`, 10, 80);
  }
}
 Call updateFPS() and drawFPS(ctx) in your game loop.

üßº Cleanup on Release
 8. Disable for Public Builds
 Before publishing the game:

Set debugMode = false

Remove any heavy logging

Keep shortcuts but make them do nothing if debugMode === false

